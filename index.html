<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Echoes of Yourself — Expanded Prototype (Stable)</title>
  <style>
    :root{--bg:#0b0f1a;--panel:#0f1724;--accent:#8be9fd;--muted:#98a0b3}
    html,body{height:100%;margin:0;font-family:Inter,Segoe UI,system-ui,Arial}
    body{background:linear-gradient(180deg,#061025 0%, #0b1220 100%);color:#dfe8f2;display:flex;align-items:center;justify-content:center}
    #app{width:1200px;max-width:98vw;background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);border-radius:14px;padding:18px;box-shadow:0 10px 40px rgba(2,6,23,0.7)}
    .row{display:flex;gap:16px}
    .viewport{background:radial-gradient(circle at 20% 10%, rgba(139,233,253,0.03), transparent), #071124;border-radius:8px;padding:12px;flex:1;min-height:640px}
    canvas{display:block;background:transparent;border-radius:8px;width:100%;height:600px}
    .sidebar{width:360px;background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);padding:12px;border-radius:8px}
    h1{font-size:20px;margin:6px 0}
    .menu{display:flex;flex-direction:column;gap:10px}
    button{background:var(--panel);color:var(--accent);border:1px solid rgba(139,233,253,0.12);padding:10px;border-radius:8px;cursor:pointer}
    .btn-flat{background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--muted)}
    label{font-size:12px;color:var(--muted)}
    input[type=color]{height:36px;width:100%;border-radius:6px;border:0;padding:0}
    .preview{width:100%;height:120px;background:linear-gradient(180deg,#031025,#071124);border-radius:8px;display:flex;align-items:center;justify-content:center}
    .small{font-size:13px;color:var(--muted)}
    .credits{font-size:12px;color:var(--muted);margin-top:8px}
    select{padding:8px;border-radius:6px;border:0;background:rgba(255,255,255,0.02);color:inherit}
    .level-list{display:flex;flex-wrap:wrap;gap:8px}
    .level-card{padding:8px;border-radius:6px;background:rgba(255,255,255,0.02);cursor:pointer;border:1px solid rgba(255,255,255,0.02)}
    .hud{position:absolute;left:24px;top:22px;color:#cfe9ff}
    .cutscene{position:relative;background:linear-gradient(180deg, rgba(0,0,0,0.6), rgba(0,0,0,0.45));padding:20px;border-radius:8px}
  </style>
</head>
<body>
  <div id="app">
    <div class="row">
      <div class="viewport">
        <div id="game-root" style="position:relative">
          <canvas id="gameCanvas" width="920" height="600"></canvas>
          <div id="ui" style="position:absolute;left:18px;top:18px;"></div>
        </div>
      </div>
      <div class="sidebar">
        <h1>Echoes — Stable Menu</h1>
        <div class="menu">
          <button id="btnStart">Continue / Start</button>
          <button id="btnLevelSelect" class="btn-flat">Level Select</button>
          <button id="btnInventory" class="btn-flat">Upgrades / Inventory</button>
          <div style="margin-top:6px">
            <label class="small">Character Color</label>
            <input id="charColor" type="color" value="#8be9fd" />
          </div>
          <div>
            <label class="small">Hat</label>
            <select id="charHat">
              <option value="none">None</option>
              <option value="cap">Cap</option>
              <option value="hood">Hood</option>
              <option value="crown">Crown</option>
            </select>
          </div>
          <div class="preview" id="preview">
            <canvas id="previewCanvas" width="260" height="100"></canvas>
          </div>

          <div class="small muted">Controls: Arrow keys / WASD to move, Space to dash, Enter to interact, P to pause</div>

          <div style="display:flex;gap:8px;align-items:center;justify-content:space-between">
            <div class="small muted">XP: <span id="xpVal">0</span></div>
            <div class="small muted">Coins: <span id="coinsVal">0</span></div>
          </div>

          <div class="small muted">Quick Level Select</div>
          <div class="level-list" id="levelList"></div>

          <div class="credits">Prototype — stable baseline. Core systems reviewed and fixed.</div>
        </div>
      </div>
    </div>
  </div>

  <script>
  // ===============
  // Stable core patch applied:
  // - Fixed entity deletion during iteration (now marks dead, then filters)
  // - Inventory purchase deducts both STATE and saved coins
  // - Enter key in menu continues from saved unlocked level (not always level 1)
  // - Minor stability tweaks and comments
  // ===============

  (() => {
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const previewCanvas = document.getElementById('previewCanvas');
    const pctx = previewCanvas.getContext('2d');

    // UI elements
    const btnStart = document.getElementById('btnStart');
    const btnLevelSelect = document.getElementById('btnLevelSelect');
    const btnInventory = document.getElementById('btnInventory');
    const charColorIn = document.getElementById('charColor');
    const charHat = document.getElementById('charHat');
    const xpVal = document.getElementById('xpVal');
    const coinsVal = document.getElementById('coinsVal');
    const levelListEl = document.getElementById('levelList');

    // persistent save
    const SAVE_KEY = 'echoes_save_v1';
    function loadSave(){
      try{ const s = JSON.parse(localStorage.getItem(SAVE_KEY)||'{}'); return Object.assign({unlocked:1, xp:0, coins:0, custom:{color:'#8be9fd',hat:'none'}}, s); }catch(e){return {unlocked:1,xp:0,coins:0,custom:{color:'#8be9fd',hat:'none'}}}
    }
    function saveGame(){
      // keep saveData in sync with STATE
      saveData.xp = STATE.xp; saveData.coins = STATE.coins; saveData.unlocked = saveData.unlocked; saveData.custom = saveData.custom;
      localStorage.setItem(SAVE_KEY, JSON.stringify({unlocked:saveData.unlocked, xp:saveData.xp, coins:saveData.coins, custom:saveData.custom}));
      updateSidebar();
    }
    const saveData = loadSave();

    const STATE = { mode:'menu', currentLevel:0, levels:[], player:null, entities:[], echoes:[], keys:{}, lastTimestamp:0, cutscene:null, xp:saveData.xp, coins:saveData.coins };

    // utils
    function clamp(v,a,b){return Math.max(a,Math.min(b,v))}
    function rand(min,max){return Math.random()*(max-min)+min}

    // Player
    class Player{
      constructor(x,y,color){ this.x=x;this.y=y;this.vx=0;this.vy=0;this.w=28;this.h=36;this.color=color;this.speed=170;this.onGround=false;this.health=100;this.maxHealth=100;this.dashCooldown=0;this.facing=1;this.recording=[]; this.xp=0; this.coins=0; }
      update(dt){
        let move=0; if(STATE.keys.ArrowLeft||STATE.keys.KeyA) move-=1; if(STATE.keys.ArrowRight||STATE.keys.KeyD) move+=1; if(move!==0) this.facing = move>0?1:-1; this.vx = move*this.speed; this.vy += 800*dt; this.x += this.vx*dt; this.y += this.vy*dt; if(this.y>H-70){this.y=H-70;this.vy=0;this.onGround=true}
        if((STATE.keys.Space||STATE.keys.KeyX) && this.dashCooldown<=0){ this.vx += this.facing*420; this.dashCooldown = 0.9; }
        this.dashCooldown = Math.max(0, this.dashCooldown - dt);
        // record position snapshot for echoes
        this.recording.push({x:this.x,y:this.y}); if(this.recording.length>900) this.recording.shift();
        this.x = clamp(this.x,10,W-10-this.w);
      }
      draw(ctx,alpha=1){ ctx.save(); ctx.globalAlpha=alpha; ctx.translate(this.x+this.w/2,this.y+this.h/2); ctx.fillStyle=this.color; ctx.fillRect(-this.w/2,-this.h/2,this.w,this.h); ctx.fillStyle='#061224'; ctx.fillRect(-8,-8,6,6); ctx.fillRect(2,-8,6,6); const hat = saveData.custom.hat; if(hat==='cap'){ ctx.fillStyle='#222'; ctx.fillRect(-14,-18,28,6);} else if(hat==='hood'){ ctx.strokeStyle='#fff'; ctx.beginPath(); ctx.arc(0,-2,20,Math.PI*1.1,Math.PI*1.9); ctx.stroke(); } else if(hat==='crown'){ ctx.fillStyle='#ffcc33'; ctx.beginPath(); ctx.moveTo(-14,-16); ctx.lineTo(-6,-6); ctx.lineTo(0,-14); ctx.lineTo(6,-6); ctx.lineTo(14,-16); ctx.closePath(); ctx.fill(); } ctx.restore(); }
    }

    // Echo replay
    class Echo{ constructor(recording,color){ this.recording = recording.slice(); this.t=0; this.idx=0; this.x=this.recording[0]?.x||0; this.y=this.recording[0]?.y||0; this.color=color; } update(dt){ this.t += dt; this.idx = Math.floor(this.t*60); if(this.idx >= this.recording.length) { this.dead=true; return; } const s = this.recording[this.idx]; if(s){ this.x=s.x; this.y=s.y; } } draw(ctx){ ctx.save(); ctx.globalAlpha=0.5; ctx.translate(this.x+14,this.y+18); ctx.fillStyle=this.color; ctx.fillRect(-14,-18,28,36); ctx.restore(); } }

    // Enemy
    class Enemy{ constructor(x,y,type='grunt'){ this.x=x;this.y=y;this.w=30;this.h=34;this.type=type;this.vx=0;this.health = type==='boss'?400:60;this.ang=rand(0,Math.PI*2);this.state='idle'; this._dead=false; } update(dt){ this.ang += dt; if(this.type==='grunt'){ this.x += Math.sin(this.ang*1.6)*40*dt; } else if(this.type==='shooter'){ this.x += Math.cos(this.ang*0.9)*20*dt; } } draw(ctx){ ctx.save(); ctx.translate(this.x+this.w/2,this.y+this.h/2); ctx.fillStyle=(this.type==='boss')?'#ff6b6b':(this.type==='shooter'?'#a6ffb0':'#ffb86b'); ctx.fillRect(-this.w/2,-this.h/2,this.w,this.h); if(this.type==='boss'){ ctx.fillStyle='#fff'; ctx.fillText('BOSS', -18, 6); } ctx.restore(); } }

    // Boss behaviors
    function spawnBossPattern(boss){ boss.phase = 0; boss.timer = 0; boss.update = function(dt){ this.timer += dt; if(this.phase===0){ this.x += Math.sin(this.timer*1.2)*120*dt; this.y = 120 + Math.cos(this.timer*0.9)*20; if(this.timer>6){ this.phase=1; this.timer=0; } } else if(this.phase===1){ if(this.timer>0.8){ const targetX = (STATE.player.x||W/2); this.x += (targetX - this.x) * dt * 3; this.y += 200*dt; if(this.y>H-120){ this.y = 120; this.phase=0; this.timer=0; } } } }; }

    // Level definitions - more detailed
    function makeLevels(){
      return [
        { id:0, name:'Ravenwood Edge', enemies:[{x:360,y:460},{x:560,y:460}], boss:false, cutscene:['You awake at the edge of Ravenwood.','You feel a pull — a memory missing.'] },
        { id:1, name:'Forgotten Cemetery', enemies:[{x:260,y:460},{x:460,y:460},{x:720,y:460}], boss:false, cutscene:['Tombs whisper. The echoes tremble.'] },
        { id:2, name:'Whispering Hollow', enemies:[{x:200,y:460, type:'shooter'},{x:420,y:460},{x:680,y:460}], boss:false, cutscene:['A hollow forms — echoes multiply.'] },
        { id:3, name:'Shadow Market', enemies:[{x:300,y:460},{x:360,y:460},{x:620,y:460},{x:760,y:460}], boss:false, cutscene:['A market frozen in time. Take care.'] },
        { id:4, name:'Eldritch Approach', enemies:[{x:360,y:420},{x:520,y:420},{x:680,y:420}], boss:false, cutscene:['The shrine draws near.'] },
        { id:5, name:'Eldritch Shrine — Warden', enemies:[{x:420,y:200, type:'boss'}], boss:true, cutscene:['The Warden stirs... He prizes obedience.'] },
        { id:6, name:'Abyssal Paths', enemies:[{x:240,y:460},{x:440,y:460},{x:640,y:460},{x:840,y:460}], boss:false, cutscene:['The path below hums with pressure.'] },
        { id:7, name:'Wraithcaller — Final', enemies:[{x:420,y:180,type:'boss'}], boss:true, cutscene:['The Wraithcaller returns. This is the final stand.'] }
      ];
    }

    // Cutscene manager - supports portrait slide
    class Cutscene{ constructor(lines, portrait, onEnd){ this.lines = lines; this.portrait = portrait; this.step=0; this.t=0; this.onEnd=onEnd; this.active=true; } update(dt){ this.t+=dt; if(this.t>3.2){ this.step++; this.t=0; } if(this.step >= this.lines.length){ this.active=false; if(this.onEnd) this.onEnd(); } } draw(ctx){ ctx.save(); ctx.fillStyle='rgba(0,0,0,0.7)'; ctx.fillRect(40,360,840,160); ctx.fillStyle='#cfe9ff'; ctx.font='18px Inter'; ctx.fillText(this.lines[this.step] || '', 140, 420); if(this.portrait){ ctx.fillStyle=this.portrait; ctx.fillRect(60,390,64,64); } ctx.restore(); } }

    function loadLevel(idx, fromMenu=false){ STATE.entities=[]; STATE.echoes=[]; const lvl = STATE.levels[idx]; STATE.player = new Player(90,H-120, saveData.custom.color); STATE.player.coins = 0; STATE.currentLevel = idx; // spawn enemies
      lvl.enemies.forEach(e=>{ const en = new Enemy(e.x,e.y,e.type||'grunt'); STATE.entities.push(en); });
      STATE.mode='cutscene'; STATE.cutscene = new Cutscene(lvl.cutscene, '#8be9fd', ()=>{ STATE.mode='playing'; if(lvl.boss){ const boss = new Enemy(W/2 - 60, 140, 'boss'); boss.w=140; boss.h=140; boss.health = 800; spawnBossPattern(boss); STATE.entities.push(boss); } }); }

    // Start-level reward/next handling
    function onLevelComplete(){ const lvl = STATE.levels[STATE.currentLevel]; const awardXP = 50 + STATE.currentLevel*10; const coins = 10 + STATE.currentLevel*5; STATE.xp += awardXP; STATE.coins += coins; // keep saveData synced
      saveData.xp = STATE.xp; saveData.coins = STATE.coins; saveData.unlocked = Math.max(saveData.unlocked, STATE.currentLevel+2); saveGame(); updateSidebar(); }

    // Game loop
    function update(dt){ if(STATE.mode==='menu') return; if(STATE.mode==='cutscene'){ if(STATE.cutscene){ STATE.cutscene.update(dt); if(!STATE.cutscene.active){ STATE.mode='playing'; } } return; }
      if(!STATE.player) return; STATE.player.update(dt); STATE.entities.forEach(e=>e.update(dt)); STATE.echoes.forEach(ec=>ec.update(dt)); STATE.echoes = STATE.echoes.filter(ec=>!ec.dead);
      // collisions and combat
      // mark-dead approach to avoid splice-in-loop bugs
      STATE.entities.forEach((e)=>{ if(e._dead) return; if(Math.abs((STATE.player.x+14)-(e.x+e.w/2))<36 && Math.abs((STATE.player.y+18)-(e.y+e.h/2))<44){ // collision
            STATE.player.health -= (e.type==='boss')?0.6:0.18; if(STATE.player.health<0) STATE.player.health=0; if(e.type!=='boss'){ e.health -= 60*dt; if(e.health<=0){ e._dead = true; STATE.player.coins += 2; } } else { e.health -= 12*dt; if(e.health<=0) e._dead = true; }
          } });
      // remove dead entities after processing
      const hadBoss = STATE.entities.some(e=>e.type==='boss');
      STATE.entities = STATE.entities.filter(e=>!e._dead);

      // check boss death
      const boss = STATE.entities.find(e=>e.type==='boss');
      if(!boss && hadBoss && STATE.levels[STATE.currentLevel].boss){ // boss was present and now gone
        // create echo
        STATE.echoes.push(new Echo(STATE.player.recording, STATE.player.color));
        STATE.mode='cutscene'; STATE.cutscene = new Cutscene(['The boss collapses...','Memories return piece by piece.'], '#ff6b6b', ()=>{ onLevelComplete(); STATE.mode='menu'; }); }

      // check level clear (no enemies and not a boss level)
      const nonBoss = STATE.entities.filter(e=>e.type!=='boss'); if(nonBoss.length===0 && !STATE.levels[STATE.currentLevel].boss){ STATE.echoes.push(new Echo(STATE.player.recording, STATE.player.color)); onLevelComplete(); // short delay then next level
        setTimeout(()=>{ const next = Math.min(STATE.levels.length-1, STATE.currentLevel+1); loadLevel(next); }, 700); }
    }

    function draw(){ ctx.clearRect(0,0,W,H); const g = ctx.createLinearGradient(0,0,0,H); g.addColorStop(0,'#081028'); g.addColorStop(1,'#071124'); ctx.fillStyle=g; ctx.fillRect(0,0,W,H); ctx.fillStyle='#071220'; ctx.fillRect(0,H-60,W,60);
      // draw entities
      STATE.entities.forEach(e=>e.draw(ctx)); STATE.echoes.forEach(ec=>ec.draw(ctx)); if(STATE.player) STATE.player.draw(ctx);
      // HUD
      ctx.fillStyle='#cfe9ff'; ctx.font='15px Inter'; ctx.fillText('Level: '+(STATE.levels[STATE.currentLevel]?.name || '—'), 600, 28); ctx.fillText('Health: '+Math.floor(STATE.player?.health||0), 600, 50);
      // draw cutscene overlay
      if(STATE.mode==='cutscene' && STATE.cutscene){ STATE.cutscene.draw(ctx); }
    }

    function loop(ts){ if(!STATE.lastTimestamp) STATE.lastTimestamp=ts; const dt = Math.min(0.05,(ts-STATE.lastTimestamp)/1000); STATE.lastTimestamp = ts; update(dt); draw(); requestAnimationFrame(loop); }

    // input
    window.addEventListener('keydown',(e)=>{ STATE.keys[e.code]=true; if(e.code==='Enter' && STATE.mode==='menu'){ // continue from saved progress
          const startLevel = Math.max(0, (saveData.unlocked-1)); loadLevel(startLevel); } if(e.code==='KeyP'){ // pause toggle
          STATE.mode = (STATE.mode==='playing')?'paused':(STATE.mode==='paused'?'playing':STATE.mode); } });
    window.addEventListener('keyup',(e)=>{ STATE.keys[e.code]=false; });

    // UI handlers
    btnStart.addEventListener('click', ()=>{ const startLevel = Math.max(0, saveData.unlocked-1); loadLevel(startLevel); });
    btnLevelSelect.addEventListener('click', ()=>{ const choice = prompt('Enter level number (1-'+STATE.levels.length+') to jump to (unlocked up to '+saveData.unlocked+').'); const n = parseInt(choice); if(!isNaN(n) && n>=1 && n<=STATE.levels.length && n<=saveData.unlocked){ loadLevel(n-1); } else alert('Invalid or locked'); });
    btnInventory.addEventListener('click', ()=>{ // purchase example — correctly uses STATE and saveData
      const cost = 20; if(STATE.coins >= cost){ if(confirm('Spend '+cost+' coins to increase max health by 20?')){ STATE.coins -= cost; saveData.coins = STATE.coins; // apply upgrade (simple example)
            if(STATE.player) { STATE.player.maxHealth = (STATE.player.maxHealth || 100) + 20; STATE.player.health = Math.min(STATE.player.maxHealth, STATE.player.health + 20); }
            saveGame(); alert('Purchased!'); } } else alert('Not enough coins'); });

    charColorIn.addEventListener('input', ()=>{ saveData.custom.color = charColorIn.value; saveGame(); drawPreview(); }); charHat.addEventListener('change', ()=>{ saveData.custom.hat = charHat.value; saveGame(); drawPreview(); });

    function drawPreview(){ pctx.clearRect(0,0,previewCanvas.width,previewCanvas.height); pctx.fillStyle='#041026'; pctx.fillRect(0,0,previewCanvas.width,previewCanvas.height); const px = previewCanvas.width/2 - 10, py = previewCanvas.height/2 - 12; pctx.fillStyle=saveData.custom.color; pctx.fillRect(px,py,20,28); const hat = saveData.custom.hat; pctx.fillStyle='#222'; if(hat==='cap') pctx.fillRect(px-6,py-6,32,6); if(hat==='crown'){ pctx.fillStyle='#ffcc33'; pctx.beginPath(); pctx.moveTo(px-6,py-6); pctx.lineTo(px-2,py+4); pctx.lineTo(px+6,py-6); pctx.lineTo(px+14,py+4); pctx.lineTo(px+20,py-6); pctx.closePath(); pctx.fill(); } }

    // sidebar level list
    function updateSidebar(){ levelListEl.innerHTML=''; STATE.levels.forEach((lv,i)=>{ const el = document.createElement('div'); el.className='level-card'; el.textContent = (i+1)+'. '+lv.name + (i+1<=saveData.unlocked?'':' (locked)'); el.addEventListener('click', ()=>{ if(i+1<=saveData.unlocked){ loadLevel(i); } else alert('Locked'); }); levelListEl.appendChild(el); }); xpVal.textContent = STATE.xp; coinsVal.textContent = STATE.coins; }

    // init
    STATE.levels = makeLevels(); // apply saved customizations
    charColorIn.value = saveData.custom.color || '#8be9fd'; charHat.value = saveData.custom.hat || 'none'; drawPreview(); updateSidebar(); requestAnimationFrame(loop);

    // expose basic API for debugging and manual checks
    window.GAME = {STATE, saveData, loadLevel, saveGame, updateSidebar};
  })();
  </script>
</body>
</html>
