<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Starfall Protocol — Prototype</title>
<style>
  :root{
    --bg:#040814; --panel:#07102a; --accent:#5fe3ff; --muted:#98a0b3;
  }
  html,body{height:100%;margin:0;font-family:Inter,Segoe UI,system-ui,Arial;background:linear-gradient(180deg,#010414,#071026);color:#e6f7ff}
  #wrap{display:flex;gap:12px;align-items:stretch;max-width:1400px;margin:18px auto;padding:12px;width:calc(100% - 48px)}
  .viewport{flex:1;background:linear-gradient(180deg,#05122a,#020617);border-radius:10px;padding:10px;display:flex;align-items:center;justify-content:center;position:relative;min-height:520px}
  canvas{width:100%;height:100%;display:block;border-radius:8px;background:transparent}
  .panel{width:360px;background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);padding:12px;border-radius:10px;box-sizing:border-box}
  h1{font-size:18px;margin:4px 0}
  button{background:var(--panel);color:var(--accent);border:1px solid rgba(95,227,255,0.12);padding:10px;border-radius:8px;cursor:pointer;width:100%}
  .muted{color:var(--muted);font-size:13px}
  .small{font-size:13px}
  .row{display:flex;gap:8px}
  .stat{background:rgba(255,255,255,0.02);padding:8px;border-radius:6px;margin-bottom:8px}
  input[type=range]{width:100%}
  .center{display:flex;align-items:center;justify-content:center}
  .credits{font-size:12px;color:var(--muted);margin-top:8px}
</style>
</head>
<body>
<div id="wrap">
  <div class="viewport">
    <canvas id="game"></canvas>
    <!-- Overlay UI drawn by JS (cutscenes, HUD) -->
  </div>

  <div class="panel">
    <h1>Starfall Protocol — Menu</h1>
    <div class="stat">
      <div class="small muted">Ship</div>
      <div id="shipPreview" class="center" style="height:80px"></div>
    </div>

    <div class="small muted">Coins: <span id="coins">0</span>  •  Score: <span id="score">0</span></div>
    <div style="height:8px"></div>

    <button id="btnStart">ENTER MISSION (Enter)</button>
    <div style="height:8px"></div>
    <button id="btnNextMission" class="muted">Next Mission (auto unlocks)</button>
    <div style="height:12px"></div>

    <h1 style="font-size:15px">Upgrades</h1>
    <div class="stat">
      <div class="small">Engine Speed: <span id="uSpeedVal">0</span></div>
      <input id="uSpeed" type="range" min="0" max="5" step="1">
      <button id="buySpeed">Buy/Set</button>
    </div>

    <div class="stat">
      <div class="small">Fire Rate: <span id="uFireVal">0</span></div>
      <input id="uFire" type="range" min="0" max="5" step="1">
      <button id="buyFire">Buy/Set</button>
    </div>

    <div class="stat">
      <div class="small">Shield (HP Bonus): <span id="uShieldVal">0</span></div>
      <input id="uShield" type="range" min="0" max="5" step="1">
      <button id="buyShield">Buy/Set</button>
    </div>

    <div style="height:8px"></div>
    <div class="muted small">Controls: Arrow/WASD to move, Z or Space to shoot, P to pause, Enter to start. Close this panel to play full-screen.</div>
    <div class="credits">Prototype — cinematic cutscenes included. Save stored locally.</div>
  </div>
</div>

<script>
/* Starfall Protocol Prototype
   - Responsive canvas with DPR handling
   - Menu with upgrades (saved in localStorage)
   - Missions with pre/post cutscenes (holographic style)
   - Ship: move + shoot
   - Asteroids + small enemies + boss telegraphed attack
*/

(() => {
  // ---- Config / Save
  const SAVE_KEY = 'starfall_proto_save_v1';
  const defaultSave = {
    coins: 50,
    score: 0,
    upgrades: { speed: 1, fire: 1, shield: 0 },
    missionUnlocked: 1
  };
  let SAVE = loadSave();

  function loadSave(){
    try{
      return Object.assign({}, defaultSave, JSON.parse(localStorage.getItem(SAVE_KEY) || '{}'));
    }catch(e){ return Object.assign({}, defaultSave); }
  }
  function saveNow(){ localStorage.setItem(SAVE_KEY, JSON.stringify(SAVE)); updateMenu(); }

  // ---- Canvas setup
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  let W = 900, H = 560;
  function fitCanvas(){
    const rect = canvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    // we will set logical size from rect to allow CSS scaling
    const w = Math.floor(rect.width), h = Math.floor(rect.height);
    canvas.width = Math.max(800, Math.floor(w * dpr));
    canvas.height = Math.max(480, Math.floor(h * dpr));
    ctx.setTransform(dpr,0,0,dpr,0,0);
    W = Math.max(800, w);
    H = Math.max(480, h);
  }
  // place canvas into viewport size
  function setupCanvasSize(){
    const vp = document.querySelector('.viewport');
    canvas.style.width = vp.clientWidth + 'px';
    canvas.style.height = vp.clientHeight + 'px';
    fitCanvas();
  }
  window.addEventListener('resize', ()=>{ setupCanvasSize(); });
  // init
  setupCanvasSize();

  // ---- UI elements
  const coinsEl = document.getElementById('coins');
  const scoreEl = document.getElementById('score');
  const btnStart = document.getElementById('btnStart');
  const btnNextMission = document.getElementById('btnNextMission');
  const uSpeed = document.getElementById('uSpeed');
  const uFire = document.getElementById('uFire');
  const uShield = document.getElementById('uShield');
  const uSpeedVal = document.getElementById('uSpeedVal');
  const uFireVal = document.getElementById('uFireVal');
  const uShieldVal = document.getElementById('uShieldVal');
  const buySpeed = document.getElementById('buySpeed');
  const buyFire = document.getElementById('buyFire');
  const buyShield = document.getElementById('buyShield');
  const shipPreview = document.getElementById('shipPreview');

  // init sliders to saved
  uSpeed.value = SAVE.upgrades.speed;
  uFire.value  = SAVE.upgrades.fire;
  uShield.value= SAVE.upgrades.shield;

  // ---- Input
  const keys = {};
  window.addEventListener('keydown', (e) => {
    keys[e.code] = true;
    // prevent page scroll
    if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','Space'].includes(e.code)) e.preventDefault();
    if(e.code === 'Enter') startMission(SAVE.missionUnlocked - 1);
    if(e.code === 'KeyP') togglePause();
  });
  window.addEventListener('keyup', (e) => { keys[e.code] = false; });

  // ---- Game state
  let STATE = {
    mode: 'menu', // menu, cutscene_in, playing, cutscene_out, paused
    missionIndex: 0,
    player: null,
    bullets: [],
    asteroids: [],
    enemies: [],
    particles: [],
    boss: null,
    score: SAVE.score,
    coins: SAVE.coins,
    missionTimer: 0,
    waveTimer: 0
  };

  // ---- Utility
  function rand(min, max){ return Math.random()*(max-min)+min; }
  function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }
  function now(){ return performance.now(); }

  // ---- Player (ship)
  class Player {
    constructor(){
      this.w = 36; this.h = 36;
      this.x = W/2 - this.w/2;
      this.y = H - 120;
      this.vx = 0; this.vy = 0;
      this.speedBase = 220; // base
      this.fireCooldown = 0;
      this.maxHP = 100 + (SAVE.upgrades.shield * 20);
      this.hp = this.maxHP;
      this.color = '#5fe3ff';
    }
    get speed(){ return this.speedBase + (SAVE.upgrades.speed * 40); }
    get fireRate(){ return Math.max(0.09, 0.28 - (SAVE.upgrades.fire * 0.035)); } // lower = faster
    update(dt){
      // movement
      let mx = 0, my = 0;
      if(keys.ArrowLeft || keys.KeyA) mx -= 1;
      if(keys.ArrowRight || keys.KeyD) mx += 1;
      if(keys.ArrowUp || keys.KeyW) my -= 1;
      if(keys.ArrowDown || keys.KeyS) my += 1;
      // apply
      this.vx += (mx * this.speed - this.vx) * Math.min(1, 12*dt);
      this.vy += (my * this.speed - this.vy) * Math.min(1, 12*dt);
      this.x += this.vx * dt;
      this.y += this.vy * dt;
      // bounds
      this.x = clamp(this.x, 12, W - 12 - this.w);
      this.y = clamp(this.y, 12, H - 120);
      // shooting
      this.fireCooldown -= dt;
      if((keys.KeyZ || keys.Space) && this.fireCooldown <= 0){
        shootBullet(this.x + this.w/2, this.y + 6, -500);
        this.fireCooldown = this.fireRate;
      }
    }
    draw(ctx){
      ctx.save();
      ctx.translate(this.x + this.w/2, this.y + this.h/2);
      // ship body - simple triangle + core
      ctx.fillStyle = this.color;
      ctx.beginPath();
      ctx.moveTo(0,-14);
      ctx.lineTo(14,12);
      ctx.lineTo(-14,12);
      ctx.closePath();
      ctx.fill();
      ctx.fillStyle = '#041122';
      ctx.fillRect(-6, -4, 12, 8);
      // engine glow
      ctx.fillStyle = 'rgba(95,227,255,0.12)';
      ctx.beginPath(); ctx.ellipse(0,16,12,6,0,0,Math.PI*2); ctx.fill();
      ctx.restore();
    }
  }

  // ---- Bullets
  class Bullet {
    constructor(x,y,vy){
      this.x = x; this.y = y; this.vy = vy;
      this.r = 4; this.dead = false;
    }
    update(dt){
      this.y += this.vy * dt;
      if(this.y < -20 || this.y > H + 20) this.dead = true;
    }
    draw(ctx){
      ctx.save();
      ctx.fillStyle = '#7efcff';
      ctx.beginPath(); ctx.ellipse(this.x, this.y, this.r, this.r, 0,0,Math.PI*2); ctx.fill();
      ctx.restore();
    }
  }

  // ---- Asteroid
  class Ast {
    constructor(x,y,size=1){
      this.x = x; this.y = y; this.size = size; // size 1..3
      this.r = 10 + (size*8);
      this.vx = rand(-40,40); this.vy = rand(40,160);
      this.angle = rand(0,Math.PI*2); this.spin = rand(-1.5,1.5);
      this.dead = false;
    }
    update(dt){
      this.x += this.vx*dt; this.y += this.vy*dt; this.angle += this.spin*dt;
      if(this.y > H + 80 || this.x < -120 || this.x > W + 120) this.dead = true;
    }
    draw(ctx){
      ctx.save(); ctx.translate(this.x,this.y); ctx.rotate(this.angle);
      ctx.fillStyle = '#8e8e8e';
      ctx.beginPath();
      for(let i=0;i<8;i++){
        const a = i/8*Math.PI*2;
        const r = this.r * (0.75 + Math.sin(i*1.6 + this.angle)*0.18);
        const px = Math.cos(a)*r, py = Math.sin(a)*r;
        if(i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
      }
      ctx.closePath(); ctx.fill(); ctx.restore();
    }
  }

  // ---- Enemy ship (small)
  class Enemy {
    constructor(x,y){
      this.x=x; this.y=y; this.w=28; this.h=28; this.vx = rand(-40,40); this.vy = rand(30,60);
      this.hp = 30; this.dead=false; this.type='fighter';
    }
    update(dt){
      // move down and zigzag
      this.x += Math.sin(performance.now()*0.001 + this.x)*20*dt;
      this.y += this.vy*dt;
      if(this.y > H + 40) this.dead = true;
      // small chance to shoot
      if(Math.random() < 0.002) {
        shootEnemyBullet(this.x + this.w/2, this.y + this.h, 220);
      }
    }
    draw(ctx){
      ctx.save(); ctx.translate(this.x + this.w/2, this.y + this.h/2);
      ctx.fillStyle = '#ffb86b';
      ctx.fillRect(-14,-10,28,20);
      ctx.fillStyle = '#2a0e00'; ctx.fillRect(-6,-6,12,6);
      ctx.restore();
    }
  }

  // ---- Boss (telegraphed attacks)
  class Boss {
    constructor(){
      this.w = 220; this.h = 160;
      this.x = (W - this.w)/2; this.y = 60;
      this.hpMax = 1200; this.hp = this.hpMax;
      this.phase = 0; this.timer = 0; this.invul = false; this.dead=false;
    }
    update(dt){
      this.timer += dt;
      // simple phase machine
      if(this.phase === 0){
        // hover side-to-side
        this.x = (W - this.w)/2 + Math.sin(this.timer*0.6) * Math.min(250, W*0.16);
        if(this.timer > 6){ this.phase = 1; this.timer = 0; this.invul = true; }
      } else if(this.phase ===1){
        // telegraph slam: red flash area, then slam (we'll spawn projectiles)
        if(this.timer > 1.2 && this.invul){ this.invul = false; this.timer = 0; this.phase = 2; this.fireVolley(); }
      } else if(this.phase === 2){
        // fire phase for a few seconds
        if(this.timer > 5){ this.phase = 0; this.timer = 0; }
      }
      if(this.hp <= 0) this.dead = true;
    }
    fireVolley(){
      // spawn many projectiles falling towards player x positions
      for(let i=0;i<8;i++){
        const tx = clamp(player.x + (Math.random()-0.5)*200, 40, W-40);
        spawnBossProjectile(tx, this.y + this.h - 10);
      }
    }
    draw(ctx){
      ctx.save(); ctx.translate(this.x + this.w/2, this.y + this.h/2);
      ctx.fillStyle = '#ff6b6b'; ctx.fillRect(-this.w/2, -this.h/2, this.w, this.h);
      ctx.fillStyle = '#17060a'; ctx.fillRect(-this.w/4, -this.h/6, this.w/2, this.h/3);
      ctx.restore();
      // health bar
      const barW = Math.min(640, W - 120);
      const bx = (W - barW)/2;
      const by = 20;
      ctx.save();
      ctx.fillStyle = 'rgba(0,0,0,0.55)'; ctx.fillRect(bx-4,by-6,barW+8,28);
      ctx.fillStyle = '#333'; ctx.fillRect(bx,by,barW,16);
      const pct = clamp(this.hp / this.hpMax, 0, 1);
      ctx.fillStyle = '#ff6b6b'; ctx.fillRect(bx,by, barW * pct, 16);
      if(this.invul){ ctx.fillStyle = 'rgba(255,200,200,0.12)'; ctx.fillRect(bx,by,barW,16); }
      ctx.strokeStyle = '#eee'; ctx.strokeRect(bx,by,barW,16);
      ctx.restore();
    }
  }

  // ---- Projectiles fired by boss (danger)
  class EnemyProj {
    constructor(x,y,vy){
      this.x=x; this.y=y; this.vy=vy; this.r=6; this.dead=false;
    }
    update(dt){
      this.y += this.vy * dt;
      if(this.y > H + 40) this.dead = true;
    }
    draw(ctx){
      ctx.save();
      ctx.fillStyle = '#ffb3b3'; ctx.beginPath(); ctx.ellipse(this.x, this.y, this.r, this.r,0,0,Math.PI*2); ctx.fill();
      ctx.restore();
    }
  }

  // ---- Particles (small)
  class Particle {
    constructor(x,y,life=0.5){
      this.x=x; this.y=y; this.vx=rand(-50,50); this.vy=rand(-50,50); this.life=life; this.max=life;
    }
    update(dt){ this.life-=dt; this.x+=this.vx*dt; this.y+=this.vy*dt; }
    draw(ctx){ if(this.life<=0) return; ctx.save(); ctx.globalAlpha = clamp(this.life/this.max,0,1); ctx.fillStyle = '#7efcff'; ctx.fillRect(this.x,this.y,2,2); ctx.restore(); }
  }

  // ---- Game objects arrays helpers
  function spawnAsteroidWave(count){
    for(let i=0;i<count;i++){
      const x = rand(40, W-40);
      const y = -rand(40, 360);
      const size = Math.random() < 0.6 ? 1 : (Math.random() < 0.7 ? 2 : 3);
      STATE.asteroids.push(new Ast(x,y,size));
    }
  }
  function spawnEnemyWave(count){
    for(let i=0;i<count;i++){
      const x = rand(60, W-60);
      const y = -rand(40, 240);
      STATE.enemies.push(new Enemy(x,y));
    }
  }

  function shootBullet(x,y,vy=-500){
    const b = new Bullet(x,y,vy); STATE.bullets.push(b);
  }
  function shootEnemyBullet(x,y,vy){
    STATE.bullets.push(new Bullet(x,y,vy));
  }
  function spawnBossProjectile(x,y){
    STATE.enemies.push(new EnemyProj(x,y, 160)); // we treat enemy projectiles in enemies array to reuse update/draw lists
  }

  // hook for boss projectiles since EnemyProj not same type - will check by instanceof
  function spawnBossProjectile(x,y){ STATE.enemies.push(new EnemyProj(x,y, 220)); }

  // ---- player instance
  let player = null;

  // ---- Cutscene system (simple holographic fade + typing text)
  class Cutscene {
    constructor(lines, onEnd = ()=>{}){
      this.lines = lines; this.t = 0; this.step = 0; this.onEnd = onEnd;
      this.phase = 'in'; // in, show, out
    }
    update(dt){
      this.t += dt;
      if(this.phase === 'in'){
        if(this.t > 0.9){ this.t = 0; this.phase = 'show'; }
      } else if(this.phase === 'show'){
        if(this.t > 3.2){
          this.t = 0; this.phase = 'out';
        }
      } else if(this.phase === 'out'){
        if(this.t > 0.7){ this.onEnd(); }
      }
    }
    draw(ctx){
      // holographic panel
      ctx.save();
      // darkened background
      ctx.fillStyle = 'rgba(0,0,0,0.42)'; ctx.fillRect(0,0,W,H);
      // panel
      const pw = Math.min(880, W - 120); const ph = 160;
      const px = (W - pw)/2; const py = (H - ph)/2;
      ctx.fillStyle = 'rgba(15,25,40,0.6)'; ctx.fillRect(px,py,pw,ph);
      ctx.strokeStyle = 'rgba(95,227,255,0.18)'; ctx.strokeRect(px,py,pw,ph);
      // holographic scan lines
      ctx.fillStyle = 'rgba(95,227,255,0.02)';
      for(let i=0;i<ph;i+=6) ctx.fillRect(px,py+i,pw,2);
      // text
      ctx.fillStyle = '#cfeaff'; ctx.font = '18px Inter';
      const text = this.lines[Math.min(this.step, this.lines.length-1)] || '';
      // typing effect
      const showChars = Math.floor((this.phase==='show' ? (this.t*20) : 999));
      ctx.fillText(text.substring(0, showChars), px + 22, py + 48);
      // small hologram icon to left
      ctx.fillStyle = 'rgba(95,227,255,0.12)';
      ctx.fillRect(px + 16, py + 18, 64, 64);
      ctx.restore();
    }
  }

  // ---- Mission definitions
  const MISSIONS = [
    { title: 'Prologue — Distress Signal', waves: [ {type:'asteroids',count:6}, {type:'enemies',count:4} ], boss:false, briefing: ['Command: We lost contact with Outpost Vega. Clear debris and respond to the signal.'] },
    { title: 'Sector Run — Pirate Sweep', waves: [ {type:'asteroids',count:8}, {type:'enemies',count:6}, {type:'asteroids',count:5} ], boss:false, briefing: ['Admiral: Reports of pirate skirmish. Neutralize hostiles.'] },
    { title: 'Eldritch Rift — Wraithcaller', waves: [ {type:'asteroids',count:12}, {type:'enemies',count:8}], boss:true, briefing: ['Intel: A Wraith-class entity detected. Prepare for heavy resistance.'] }
  ];

  // ---- Start mission flow
  function startMission(index){
    if(index < 0 || index >= MISSIONS.length) index = 0;
    if(index > SAVE.missionUnlocked - 1) { alert('Mission locked'); return; }
    STATE.mode = 'cutscene_in';
    STATE.missionIndex = index;
    STATE.cutscene = new Cutscene(MISSIONS[index].briefing, ()=>{ // on end -> begin playing
      beginMission(index);
    });
  }
  function beginMission(index){
    // clear arrays
    STATE.bullets = []; STATE.asteroids = []; STATE.enemies = []; STATE.particles = []; STATE.boss = null;
    // create player with upgrades
    player = new Player();
    STATE.player = player;
    // spawn initial waves
    STATE.missionTimer = 0; STATE.waveTimer = 0; STATE.currentWave = 0;
    // spawn first wave immediately
    spawnWaveForMission(index, 0);
    // if boss mission, we'll spawn boss later after waves
    STATE.mode = 'playing';
    STATE.score = 0;
  }

  function spawnWaveForMission(index, waveIndex){
    const mission = MISSIONS[index];
    const wave = mission.waves[waveIndex];
    if(!wave) return;
    if(wave.type === 'asteroids') spawnAsteroidWave(wave.count);
    if(wave.type === 'enemies') spawnEnemyWave(wave.count);
  }

  // ---- Game tick / update
  let lastTs = 0;
  function updateFrame(ts){
    if(!lastTs) lastTs = ts;
    const dt = Math.min(0.05, (ts - lastTs)/1000);
    lastTs = ts;

    // update based on mode
    if(STATE.mode === 'cutscene_in' || STATE.mode === 'cutscene_out'){
      STATE.cutscene.update(dt);
      // if cutscene finished, mode handled in its onEnd
    } else if(STATE.mode === 'playing'){
      // player update
      if(player) player.update(dt);

      // spawn waves over time
      STATE.missionTimer += dt;
      // every ~6 seconds spawn next wave, unless boss mission then spawn boss afterwards
      if(STATE.missionTimer > 6){
        STATE.missionTimer = 0;
        // pick next wave index
        const mission = MISSIONS[STATE.missionIndex];
        // find next wave index by how many total enemies/asteroids left
        const waveIdx = Math.floor((STATE.waveTimer % 10000) % mission.waves.length); // simple round robin
        // instead use a simpler method: spawn more occasionally
        if(Math.random() < 0.9){
          const w = mission.waves[Math.floor(rand(0, mission.waves.length))];
          if(w.type === 'asteroids') spawnAsteroidWave(w.count);
          else spawnEnemyWave(w.count);
        }
      }
      // update bullets
      for(const b of STATE.bullets) b.update(dt);
      // update asteroids
      for(const a of STATE.asteroids) a.update(dt);
      // update enemies (enemy ships and enemy projectiles are in enemies array)
      for(const e of STATE.enemies) {
        if(e.update) e.update(dt);
      }
      // boss update
      if(STATE.boss){
        STATE.boss.update(dt);
      } else {
        // maybe spawn boss if mission has boss and time passed enough & no waves left
        const mission = MISSIONS[STATE.missionIndex];
        if(mission.boss && (STATE.asteroids.length + STATE.enemies.length) < 2 && STATE.missionTimer > 1.2){
          STATE.boss = new Boss();
        }
      }
      // update particles
      for(const p of STATE.particles) p.update(dt);

      // collisions: bullets vs asteroids/enemies/boss
      // bullets array may contain both player and enemy bullets (vy sign used)
      for(const b of STATE.bullets){
        if(b.dead) continue;
        // player bullets (vy < 0) hit enemies & boss
        if(b.vy < 0){
          // check enemies
          for(const e of STATE.enemies){
            if(e.dead) continue;
            // two types: Enemy (has hp) or EnemyProj (has r)
            if(e instanceof Enemy){
              const dx = b.x - (e.x + e.w/2), dy = b.y - (e.y + e.h/2);
              if(Math.abs(dx) < 20 && Math.abs(dy) < 20){
                e.hp -= 18;
                b.dead = true;
                STATE.particles.push(new Particle(b.x, b.y, 0.3));
                if(e.hp <= 0) { e.dead = true; STATE.coins += 2; STATE.score += 12; }
                break;
              }
            } else if(e instanceof EnemyProj){
              // ignore: enemy proj destroyed by player bullet
              const dx = b.x - e.x, dy = b.y - e.y;
              if(Math.hypot(dx,dy) < 14){ e.dead = true; b.dead=true; STATE.score += 4; break; }
            }
          }
          if(b.dead) continue;
          if(STATE.boss && !STATE.boss.dead && !STATE.boss.invul){
            const bx = STATE.boss.x + STATE.boss.w/2, by = STATE.boss.y + STATE.boss.h/2;
            if(Math.abs(b.x - bx) < STATE.boss.w/2 && Math.abs(b.y - by) < STATE.boss.h/2){
              STATE.boss.hp -= 18;
              b.dead = true;
              STATE.score += 10;
            }
          }
          // asteroids
          for(const a of STATE.asteroids){
            const dx = b.x - a.x, dy = b.y - a.y;
            if(Math.hypot(dx,dy) < a.r + b.r + 2){
              b.dead = true; a.dead = true;
              STATE.score += 6; STATE.coins += 1;
              // spawn fragments if size > 1
              if(a.size > 1){
                for(let k=0;k<2;k++){
                  const f = new Ast(a.x + rand(-8,8), a.y + rand(-8,8), a.size -1);
                  STATE.asteroids.push(f);
                }
              } else {
                // small pieces
                for(let k=0;k<4;k++) STATE.particles.push(new Particle(a.x + rand(-6,6), a.y + rand(-6,6), 0.4));
              }
            }
          }
        } else {
          // enemy bullet hits player
          const dx = b.x - (player.x + player.w/2), dy = b.y - (player.y + player.h/2);
          if(Math.hypot(dx,dy) < 20){
            b.dead = true; player.hp -= 12;
            for(let k=0;k<6;k++) STATE.particles.push(new Particle(player.x + rand(0, player.w), player.y + rand(0, player.h), 0.4));
          }
        }
      }

      // check collisions between asteroids/enemies and player
      for(const a of STATE.asteroids){
        if(a.dead) continue;
        const dx = (player.x + player.w/2) - a.x, dy = (player.y + player.h/2) - a.y;
        if(Math.hypot(dx,dy) < a.r + 10){
          a.dead = true;
          player.hp -= 18 + a.size * 4;
          for(let k=0;k<6;k++) STATE.particles.push(new Particle(player.x + rand(0, player.w), player.y + rand(0, player.h), 0.4));
        }
      }
      for(const e of STATE.enemies){
        if(e.dead) continue;
        if(e instanceof EnemyProj) continue; // proj handled with bullets earlier maybe
        const dx = (player.x + player.w/2) - (e.x + e.w/2);
        const dy = (player.y + player.h/2) - (e.y + e.h/2);
        if(Math.hypot(dx,dy) < 26){
          e.dead = true; player.hp -= 12;
        }
      }

      // remove dead
      STATE.bullets = STATE.bullets.filter(b => !b.dead);
      STATE.asteroids = STATE.asteroids.filter(a => !a.dead);
      STATE.enemies = STATE.enemies.filter(e => !(e.dead === true));
      STATE.particles = STATE.particles.filter(p => p.life > 0);

      // boss projectile hits
      if(STATE.boss && !STATE.boss.dead){
        // if boss dead, handle in next
      }

      // boss death check
      if(STATE.boss && STATE.boss.dead){
        // win mission
        STATE.mode = 'cutscene_out';
        // award
        SAVE.coins += 80; SAVE.score += 800; SAVE.missionUnlocked = Math.min(MISSIONS.length, SAVE.missionUnlocked + 1);
        SAVE.coins = Math.max(0, SAVE.coins);
        saveNow();
        STATE.cutscene = new Cutscene(['Mission success. Wraithcaller terminated.'], ()=>{ STATE.mode = 'menu'; STATE.player = null; });
      }

      // player death
      if(player && player.hp <= 0){
        STATE.mode = 'cutscene_out';
        STATE.cutscene = new Cutscene(['Ship destroyed. Evacuate. Mission failed.'], ()=>{ STATE.mode = 'menu'; STATE.player = null; });
      }
    }

    // update cutscene
    if(STATE.mode === 'cutscene_in' || STATE.mode === 'cutscene_out'){
      if(STATE.cutscene) STATE.cutscene.update(dt);
    }

    // update UI values
    STATE.score = STATE.score || 0;
    // save periodic small updates
    // update HUD text in DOM
    scoreEl.textContent = STATE.score;
    coinsEl.textContent = SAVE.coins;

    // draw
    render();

    requestAnimationFrame(updateFrame);
  }

  // ---- Render
  function render(){
    // clear
    ctx.clearRect(0,0,W,H);
    // background stars
    drawBackground();

    // stars parallax (simple)
    // draw asteroids
    for(const a of STATE.asteroids) a.draw(ctx);
    // draw enemies (small ships or projectiles)
    for(const e of STATE.enemies){
      if(e.draw) e.draw(ctx);
      else { /* unknown */ }
    }

    // draw boss behind player sometimes
    if(STATE.boss && !STATE.boss.dead) STATE.boss.draw(ctx);

    // draw player
    if(player) player.draw(ctx);

    // draw bullets
    for(const b of STATE.bullets) b.draw(ctx);

    // particles
    for(const p of STATE.particles) p.draw(ctx);

    // HUD overlay (top-left)
    ctx.save();
    ctx.fillStyle = '#cfe9ff'; ctx.font='14px Inter';
    ctx.fillText('Score: ' + (STATE.score || 0), 16, 22);
    ctx.fillText('Coins: ' + (SAVE.coins || 0), 16, 44);
    if(player){
      ctx.fillStyle = '#cfe9ff'; ctx.fillText('HP: ' + Math.max(0, Math.floor(player.hp)), 16, 66);
      // small health bar
      const bx = 16, by = 74, bw = 140;
      ctx.fillStyle = '#222'; ctx.fillRect(bx,by, bw, 8);
      ctx.fillStyle = '#5fe3ff'; ctx.fillRect(bx,by, bw * clamp(player.hp / player.maxHP,0,1), 8);
      ctx.strokeStyle = '#fff'; ctx.strokeRect(bx,by,bw,8);
    }
    ctx.restore();

    // if cutscene active, draw it
    if((STATE.mode==='cutscene_in' || STATE.mode==='cutscene_out') && STATE.cutscene){
      STATE.cutscene.draw(ctx);
    }

    // if in menu, draw hologram title center
    if(STATE.mode === 'menu'){
      // faint large title
      ctx.save();
      ctx.globalAlpha = 0.08;
      ctx.fillStyle = '#7efcff';
      ctx.font = '48px Inter';
      ctx.fillText('STARFALL PROTOCOL', W/2 - 260, H/2 - 40);
      ctx.restore();
    }
  }

  // simple starfield background
  const stars = [];
  for(let i=0;i<160;i++) stars.push({x:rand(0,1600),y:rand(0,1200),s:rand(0.6,2.6)});
  function drawBackground(){
    // move a bit
    for(const s of stars){
      s.y += 0.15;
      if(s.y > H + 20){ s.y = -20; s.x = rand(0,W); }
    }
    for(const s of stars){
      ctx.fillStyle = 'rgba(190,230,255,0.06)'; ctx.fillRect(s.x % W, s.y, s.s, s.s);
    }
  }

  // ---- Helpers: menu + UI logic
  function updateMenu(){
    coinsEl.textContent = SAVE.coins;
    scoreEl.textContent = SAVE.score;
    uSpeedVal.textContent = uSpeed.value;
    uFireVal.textContent  = uFire.value;
    uShieldVal.textContent= uShield.value;
    // preview ship
    shipPreview.innerHTML = '';
    const pc = document.createElement('canvas'); pc.width=120; pc.height=80; shipPreview.appendChild(pc);
    const pctx = pc.getContext('2d');
    pctx.clearRect(0,0,pc.width,pc.height);
    pctx.translate(60,40);
    pctx.fillStyle = '#5fe3ff';
    pctx.beginPath(); pctx.moveTo(0,-12); pctx.lineTo(12,10); pctx.lineTo(-12,10); pctx.closePath(); pctx.fill();
  }
  updateMenu();

  buySpeed.addEventListener('click', ()=>{ const val = parseInt(uSpeed.value); const cost = val*12; if(SAVE.coins >= cost){ SAVE.coins -= cost; SAVE.upgrades.speed = val; saveNow(); alert('Engine set to '+val); } else alert('Not enough coins'); updateMenu(); });
  buyFire.addEventListener('click', ()=>{ const val = parseInt(uFire.value); const cost = val*14; if(SAVE.coins >= cost){ SAVE.coins -= cost; SAVE.upgrades.fire = val; saveNow(); alert('Fire rate set to '+val); } else alert('Not enough coins'); updateMenu(); });
  buyShield.addEventListener('click', ()=>{ const val = parseInt(uShield.value); const cost = val*18; if(SAVE.coins >= cost){ SAVE.coins -= cost; SAVE.upgrades.shield = val; saveNow(); alert('Shield set to '+val); } else alert('Not enough coins'); updateMenu(); });

  btnStart.addEventListener('click', ()=>{ startMission(0); });
  btnNextMission.addEventListener('click', ()=>{ const next = Math.min(MISSIONS.length-1, SAVE.missionUnlocked - 1); startMission(next); });

  // ---- spawn helpers wrappers for wave functions (use local arrays)
  function spawnAsteroidWave(count){
    for(let i=0;i<count;i++){
      STATE.asteroids.push(new Ast(rand(40,W-40), -rand(40,280), (Math.random() < 0.6 ? 1 : (Math.random()<0.7?2:3))));
    }
  }
  function spawnEnemyWave(count){
    for(let i=0;i<count;i++){
      STATE.enemies.push(new Enemy(rand(60,W-60), -rand(40,220)));
    }
  }

  // ---- debug / quick test shortcuts in console
  window.STAR = {
    startMission, SAVE, STATE, spawnAsteroidWave, spawnEnemyWave, saveNow
  };

  // ---- Start main loop
  requestAnimationFrame(updateFrame);

  // ---- initial small spawn to make menu not empty
  spawnAsteroidWave(8);
  spawnEnemyWave(3);
  saveNow();

})();
</script>
</body>
</html>

