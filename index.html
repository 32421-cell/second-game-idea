<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Echoes of the Forgotten - Full Upgrade</title>
<style>
  body { margin:0; font-family:sans-serif; background:#111; overflow:hidden; }
  #gameCanvas { display:block; margin:0 auto; background:#000; }
  #cutscene { position:absolute; top:0; left:0; width:100%; height:100%; 
              background: rgba(0,0,0,0.85); color:#fff; display:flex; 
              justify-content:center; align-items:center; text-align:center;
              font-size:24px; padding:20px; cursor:pointer; z-index:5; }
  #hud { position:absolute; top:0; left:0; width:100%; height:50px; 
         background: linear-gradient(90deg,#444,#111); display:flex; 
         align-items:center; justify-content:space-around; color:#fff; font-weight:bold; font-size:18px; z-index:4; }
  button { padding:6px 12px; background:#555; border:none; border-radius:6px; color:white; cursor:pointer; transition:0.2s; }
  button:hover { background:#777; }
</style>
</head>
<body>

<audio id="bgMusic" loop>
  <source src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3" type="audio/mpeg">
</audio>

<div id="hud">
  <span id="healthBar">Lives: 3</span>
  <button id="pauseBtn">Pause</button>
  <button id="restartBtn">Restart</button>
  <button id="musicBtn">Music: On</button>
</div>

<canvas id="gameCanvas" width="900" height="500"></canvas>
<div id="cutscene"></div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const cutsceneDiv = document.getElementById('cutscene');
const bgMusic = document.getElementById('bgMusic');
const healthBar = document.getElementById('healthBar');
const pauseBtn = document.getElementById('pauseBtn');
const restartBtn = document.getElementById('restartBtn');
const musicBtn = document.getElementById('musicBtn');

let paused=false, musicOn=true, inCutscene=true;
let images = {};

// HUD buttons
pauseBtn.addEventListener('click', ()=> paused=!paused);
restartBtn.addEventListener('click', ()=> restartLevel());
musicBtn.addEventListener('click', ()=>{
  musicOn = !musicOn;
  musicOn ? bgMusic.play() : bgMusic.pause();
  musicBtn.innerText = "Music: "+(musicOn?"On":"Off");
});

// Player
let player = { x:50, y:400, width:40, height:50, color:'cyan', speed:5, vy:0, onGround:false, lives:3 };
let keys = {};
document.addEventListener('keydown', e=>keys[e.key.toLowerCase()]=true);
document.addEventListener('keyup', e=>keys[e.key.toLowerCase()]=false);

// Levels
const maps = [
  {
    bg:'https://i.ibb.co/1JpY9H3/bg1.jpg',
    platforms:[ {x:0,y:450,width:900,height:50},{x:200,y:350,width:120,height:20},{x:450,y:300,width:120,height:20},{x:700,y:250,width:120,height:20}],
    enemies:[ {x:300,y:400,width:40,height:40,color:'red',dir:1,speed:2} ],
    puzzle:{x:750,y:200,width:40,height:40,solved:false},
    passage:{x:820,y:220,width:60,height:60,active:false},
    cutscenes:["Kael enters the ruins, shadows stir...","Avoid the guardians and solve the ancient puzzle!"]
  },
  {
    bg:'https://i.ibb.co/2n6dkK5/bg2.jpg',
    platforms:[ {x:0,y:450,width:900,height:50},{x:150,y:380,width:100,height:20,move:true,dir:1,speed:1},{x:350,y:320,width:150,height:20,move:true,dir:-1,speed:1.5},{x:600,y:260,width:150,height:20},{x:750,y:200,width:100,height:20}],
    enemies:[ {x:200,y:400,width:40,height:40,color:'red',dir:1,speed:2.5},{x:500,y:350,width:40,height:60,color:'darkred',dir:-1,speed:1.2}],
    puzzle:{x:770,y:160,width:40,height:40,solved:false},
    passage:{x:820,y:180,width:60,height:60,active:false},
    cutscenes:["Level 2: The shadows grow restless...","Move quickly and solve the puzzle before they reach you!"]
  }
];

let currentLevel=0, level=maps[currentLevel], currentCutscene=0;
let particles=[], bullets=[];

// Preload images
function preloadImages(urls, callback){
  let loaded=0;
  urls.forEach(url=>{
    let img = new Image();
    img.src = url;
    img.onload = ()=>{
      loaded++;
      if(loaded === urls.length) callback();
    };
    images[url] = img;
  });
}

// Cutscene
function showCutscene(text){
  cutsceneDiv.style.display='flex';
  cutsceneDiv.innerText=text;
}
cutsceneDiv.addEventListener('click', ()=>{
  currentCutscene++;
  if(currentCutscene<level.cutscenes.length) showCutscene(level.cutscenes[currentCutscene]);
  else { cutsceneDiv.style.display='none'; inCutscene=false; if(musicOn) bgMusic.play(); }
});

// Collision
function rectCollision(a,b){ return a.x < b.x+b.width && a.x+a.width > b.x && a.y < b.y+b.height && a.y+a.height > b.y; }

// Gravity
function applyGravity(player){
  player.vy += 0.8;
  player.y += player.vy;
  player.onGround=false;
  for(let plat of level.platforms){
    if(rectCollision(player,{...plat,height:1})){
      player.y = plat.y - player.height;
      player.vy=0;
      player.onGround=true;
    }
  }
}

// Restart
function restartLevel(){
  player.x=50; player.y=400; player.vy=0; player.lives=3;
  level.puzzle.solved=false;
  level.passage.active=false;
  particles=[]; bullets=[];
  inCutscene=true; currentCutscene=0;
  healthBar.innerText='Lives: '+player.lives;
  showCutscene(level.cutscenes[0]);
}

// Particles
function spawnParticles(x,y){
  for(let i=0;i<15;i++){ particles.push({x:x, y:y, vx:(Math.random()-0.5)*4, vy:(Math.random()-1.5)*3, life:30}); }
}
function updateParticles(){
  particles.forEach(p=>{ p.x+=p.vx; p.y+=p.vy; p.vy+=0.1; p.life--; ctx.fillStyle='yellow'; ctx.fillRect(p.x,p.y,2,2); });
  particles = particles.filter(p=>p.life>0);
}

// Game Loop
function gameLoop(){
  if(!paused){
    // Background
    ctx.drawImage(images[level.bg],0,0,canvas.width,canvas.height);

    if(!inCutscene){
      // Gravity & movement
      applyGravity(player);
      if(keys['arrowleft']) player.x -= player.speed;
      if(keys['arrowright']) player.x += player.speed;
      if(keys['arrowup'] && player.onGround) player.vy=-15;

      // Moving platforms
      level.platforms.forEach(plat=>{
        if(plat.move){
          plat.x += plat.dir*plat.speed;
          if(plat.x<=0 || plat.x+plat.width>=canvas.width) plat.dir*=-1;
        }
      });

      // Platforms
      ctx.fillStyle='rgba(100,100,100,0.8)';
      level.platforms.forEach(plat=>ctx.fillRect(plat.x,plat.y,plat.width,plat.height));

      // Player
      ctx.fillStyle=player.color;
      ctx.fillRect(player.x,player.y,player.width,player.height);

      // Enemies
      level.enemies.forEach(enemy=>{
        enemy.x += enemy.dir*enemy.speed;
        if(enemy.x<=0||enemy.x+enemy.width>=canvas.width) enemy.dir*=-1;
        ctx.fillStyle=enemy.color;
        ctx.fillRect(enemy.x,enemy.y,enemy.width,enemy.height);
        if(rectCollision(player,enemy)){
          player.lives--;
          healthBar.innerText='Lives: '+player.lives;
          player.x=50; player.y=400; player.vy=0;
          if(player.lives<=0){ inCutscene=true; showCutscene("You have perished! Try again..."); restartLevel(); }
        }
      });

      // Puzzle
      ctx.fillStyle=level.puzzle.solved ? 'green' : (rectCollision(player,level.puzzle)?'orange':'yellow');
      ctx.fillRect(level.puzzle.x,level.puzzle.y,level.puzzle.width,level.puzzle.height);
      if(rectCollision(player,level.puzzle) && keys['e'] && !level.puzzle.solved){
        level.puzzle.solved=true;
        level.passage.active=true;
        spawnParticles(level.puzzle.x+20, level.puzzle.y+20);
        inCutscene=true;
        showCutscene("Puzzle solved! A passage has opened!");
      }

      // Passage
      if(level.passage.active){
        ctx.fillStyle='lightblue';
        ctx.fillRect(level.passage.x,level.passage.y,level.passage.width,level.passage.height);
        if(rectCollision(player,level.passage)){
          currentLevel++;
          if(currentLevel >= maps.length){
            inCutscene=true;
            showCutscene("Congratulations! You completed all levels!");
          } else {
            level = maps[currentLevel];
            restartLevel();
          }
        }
      }

      // Particles
      updateParticles();
    }
  }

  requestAnimationFrame(gameLoop);
}

// Start
preloadImages(maps.map(m=>m.bg), ()=>{
  showCutscene(level.cutscenes[0]);
  gameLoop();
});
</script>
</body>
</html>
